{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://angular-split/lib/utils.ts","ng://angular-split/lib/component/split.component.ts","ng://angular-split/lib/directive/splitArea.directive.ts","ng://angular-split/lib/module.ts"],"names":["__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","getPointFromEvent","event","changedTouches","undefined","x","clientX","y","clientY","getElementPixelSize","elRef","direction","rect","getBoundingClientRect","width","height","getInputBoolean","v","getInputPositiveNumber","defaultValue","Number","isNaN","isUserSizesValid","unit","sizes","total","reduce","s","every","filter","getAreaMinSize","a","size","component","lockSize","minSize","getAreaMaxSize","maxSize","getGutterSideAbsorptionCapacity","sideAreas","pixels","allAreasSizePixel","acc","area","res","areaSnapshot","pixelAbsorb","percentAfterAbsorption","sizePercentAtStart","pixelRemain","sizePixelAtStart","tempPercentSize","maxSizePixel","minSizePixel","getAreaAbsorptionCapacityPercent","containerSizePixel","tempPixelSize","getAreaAbsorptionCapacityPixel","getAreaAbsorptionCapacity","remain","list","updateAreaSize","item","SplitComponent","ngZone","cdRef","renderer","this","_direction","_unit","_gutterSize","_gutterStep","_restrictMove","_useTransition","_disabled","_dir","_gutterDblClickDuration","dragStart","EventEmitter","dragEnd","gutterClick","gutterDblClick","dragProgressSubject","Subject","dragProgress$","asObservable","isDragging","dragListeners","snapshot","startPoint","endPoint","displayedAreas","hidedAreas","_clickTimeout","Object","defineProperty","prototype","addClass","nativeElement","removeClass","build","setAttribute","_this","Observable","subscriber","transitionEndSubscriber","pipe","debounceTime","ngAfterViewInit","runOutsideAngular","setTimeout","getNbGutters","addArea","newArea","order","visible","removeArea","some","find","splice","indexOf","updateArea","resetOrders","resetSizes","showArea","areas","_a","apply","hideArea","comp","forEach","getVisibleAreaSizes","map","setVisibleAreaSizes","formatedSizes","_size","stopDragging","sort","b","setStyleOrder","useUserSizes_1","defaultSize_1","wildcardSizeAreas","alreadyGotOne_1","refreshStyleSizes","markForCheck","setStyleFlex","sumGutterSize_1","gutterSize","clickGutter","gutterNum","tempPoint","window","clearTimeout","notify","gutterDblClickDuration","startDragging","gutterOrder","preventDefault","stopPropagation","disabled","lastSteppedOffset","allInvolvedAreasSizePercent","areasBeforeGutter","areasAfterGutter","restrictMove","unshift","tslib_1.__spread","t","listen","bind","dragEvent","lockEvents","gutterEls","toArray","offset","dir","steppedOffset","Math","round","gutterStep","areasBefore","areasAfter","abs","all","areaToReset_1","unlockEvents","fct","pop","type","emit","run","ngOnDestroy","Component","args","selector","exportAs","changeDetection","ChangeDetectionStrategy","OnPush","template","NgZone","ElementRef","ChangeDetectorRef","Renderer2","Input","Output","ViewChildren","SplitAreaDirective","split","_order","_minSize","_maxSize","_lockSize","_visible","lockListeners","ngOnInit","transitionListener","propertyName","setStyle","grow","shrink","basis","isMin","isMax","Directive","AngularSplitModule","forRoot","ngModule","providers","forChild","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { ElementRef } from '@angular/core';\r\n\r\nimport { IArea, IPoint, IAreaSnapshot, ISplitSideAbsorptionCapacity, IAreaAbsorptionCapacity } from './interface';\r\n\r\nexport function getPointFromEvent(event: MouseEvent | TouchEvent): IPoint {\r\n    // TouchEvent\r\n    if((<TouchEvent> event).changedTouches !== undefined && (<TouchEvent> event).changedTouches.length > 0) {\r\n        return {\r\n            x: (<TouchEvent> event).changedTouches[0].clientX,\r\n            y: (<TouchEvent> event).changedTouches[0].clientY,\r\n        };\r\n    }\r\n    // MouseEvent\r\n    else if((<MouseEvent> event).clientX !== undefined && (<MouseEvent> event).clientY !== undefined) {\r\n        return {\r\n            x: (<MouseEvent> event).clientX,\r\n            y: (<MouseEvent> event).clientY,\r\n        };\r\n    }\r\n    return null;\r\n}\r\n\r\nexport function getElementPixelSize(elRef: ElementRef, direction: 'horizontal' | 'vertical'): number {\r\n    const rect = (<HTMLElement> elRef.nativeElement).getBoundingClientRect();\r\n\r\n    return (direction === 'horizontal') ? rect.width : rect.height;\r\n}\r\n\r\nexport function getInputBoolean(v: any): boolean {\r\n    return (typeof(v) === 'boolean') ? v : (v === 'false' ? false : true);\r\n}\r\n\r\nexport function getInputPositiveNumber<T>(v: any, defaultValue: T): number | T {\r\n    if(v === null || v === undefined) return defaultValue;\r\n\r\n    v = Number(v);\r\n    return !isNaN(v) && v >= 0 ? v : defaultValue;\r\n}\r\n\r\nexport function isUserSizesValid(unit: 'percent' | 'pixel', sizes: Array<number | null>): boolean {\r\n    // All sizes have to be not null and total should be 100\r\n    if(unit === 'percent') {\r\n        const total = sizes.reduce((total, s) => s !== null ? total + s : total, 0);\r\n        return sizes.every(s => s !== null) && total > 99.9 && total < 100.1;\r\n    }\r\n    \r\n    // A size at null is mandatory but only one.\r\n    if(unit === 'pixel') {\r\n        return sizes.filter(s => s === null).length === 1;\r\n    }\r\n}\r\n\r\nexport function getAreaMinSize(a: IArea): null | number {\r\n    if(a.size === null) {\r\n        return null;\r\n    }\r\n    \r\n    if(a.component.lockSize === true) {\r\n        return a.size;\r\n    }\r\n\r\n    if(a.component.minSize === null) {\r\n        return null;\r\n    }\r\n\r\n    if(a.component.minSize > a.size) {\r\n        return a.size;\r\n    }\r\n\r\n    return a.component.minSize;\r\n}\r\n\r\nexport function getAreaMaxSize(a: IArea): null | number {\r\n    if(a.size === null) {\r\n        return null;\r\n    }\r\n    \r\n    if(a.component.lockSize === true) {\r\n        return a.size;\r\n    }\r\n\r\n    if(a.component.maxSize === null) {\r\n        return null;\r\n    }\r\n\r\n    if(a.component.maxSize < a.size) {\r\n        return a.size;\r\n    }\r\n\r\n    return a.component.maxSize;\r\n}\r\n\r\nexport function getGutterSideAbsorptionCapacity(unit: 'percent' | 'pixel', sideAreas: Array<IAreaSnapshot>, pixels: number, allAreasSizePixel: number): ISplitSideAbsorptionCapacity {\r\n    return sideAreas.reduce((acc, area) => {\r\n        const res = getAreaAbsorptionCapacity(unit, area, acc.remain, allAreasSizePixel);\r\n        acc.list.push(res);\r\n        acc.remain  = res.pixelRemain;\r\n        return acc;\r\n    }, {remain: pixels, list: []});\r\n}\r\n\r\nfunction getAreaAbsorptionCapacity(unit: 'percent' | 'pixel', areaSnapshot: IAreaSnapshot, pixels: number, allAreasSizePixel: number): IAreaAbsorptionCapacity {\r\n    // No pain no gain\r\n    if(pixels === 0) {\r\n        return {\r\n            areaSnapshot,\r\n            pixelAbsorb: 0,\r\n            percentAfterAbsorption: areaSnapshot.sizePercentAtStart,\r\n            pixelRemain: 0,\r\n        };\r\n    }\r\n    \r\n    // Area start at zero and need to be reduced, not possible\r\n    if(areaSnapshot.sizePixelAtStart === 0 && pixels < 0) {\r\n        return {\r\n            areaSnapshot,\r\n            pixelAbsorb: 0,\r\n            percentAfterAbsorption: 0,\r\n            pixelRemain: pixels,\r\n        };\r\n    }\r\n    \r\n    if(unit === 'percent') {\r\n        return getAreaAbsorptionCapacityPercent(areaSnapshot, pixels, allAreasSizePixel);\r\n    }\r\n    \r\n\tif(unit === 'pixel') {\r\n        return getAreaAbsorptionCapacityPixel(areaSnapshot, pixels, allAreasSizePixel);\r\n    }\r\n}\r\n\r\nfunction getAreaAbsorptionCapacityPercent(areaSnapshot: IAreaSnapshot, pixels: number, allAreasSizePixel: number): IAreaAbsorptionCapacity {\r\n    const tempPixelSize = areaSnapshot.sizePixelAtStart + pixels;\r\n    const tempPercentSize = tempPixelSize / allAreasSizePixel * 100;\r\n    \r\n    // ENLARGE AREA\r\n    \r\n    if(pixels > 0) {\r\n        // If maxSize & newSize bigger than it > absorb to max and return remaining pixels \r\n        if(areaSnapshot.area.maxSize !== null && tempPercentSize > areaSnapshot.area.maxSize) {\r\n            // Use area.area.maxSize as newPercentSize and return calculate pixels remaining\r\n            const maxSizePixel = areaSnapshot.area.maxSize / 100 * allAreasSizePixel;\r\n            return {\r\n                areaSnapshot,\r\n                pixelAbsorb: maxSizePixel,\r\n                percentAfterAbsorption: areaSnapshot.area.maxSize,\r\n                pixelRemain: areaSnapshot.sizePixelAtStart + pixels - maxSizePixel\r\n            };\r\n        }\r\n        return {\r\n            areaSnapshot,\r\n            pixelAbsorb: pixels,\r\n            percentAfterAbsorption: tempPercentSize > 100 ? 100 : tempPercentSize,\r\n            pixelRemain: 0\r\n        };\r\n    }\r\n\r\n    // REDUCE AREA\r\n    \r\n    else if(pixels < 0) {\r\n        // If minSize & newSize smaller than it > absorb to min and return remaining pixels \r\n        if(areaSnapshot.area.minSize !== null && tempPercentSize < areaSnapshot.area.minSize) {\r\n            // Use area.area.minSize as newPercentSize and return calculate pixels remaining\r\n            const minSizePixel = areaSnapshot.area.minSize / 100 * allAreasSizePixel;\r\n            return {\r\n                areaSnapshot,\r\n                pixelAbsorb: minSizePixel,\r\n                percentAfterAbsorption: areaSnapshot.area.minSize,\r\n                pixelRemain: areaSnapshot.sizePixelAtStart + pixels - minSizePixel\r\n            };\r\n        }\r\n        // If reduced under zero > return remaining pixels\r\n        else if(tempPercentSize < 0) {\r\n            // Use 0 as newPercentSize and return calculate pixels remaining\r\n            return {\r\n                areaSnapshot,\r\n                pixelAbsorb: -areaSnapshot.sizePixelAtStart,\r\n                percentAfterAbsorption: 0,\r\n                pixelRemain: pixels + areaSnapshot.sizePixelAtStart\r\n            };\r\n        }\r\n        return {\r\n            areaSnapshot,\r\n            pixelAbsorb: pixels,\r\n            percentAfterAbsorption: tempPercentSize,\r\n            pixelRemain: 0\r\n        };\r\n    }\r\n}\r\n\r\nfunction getAreaAbsorptionCapacityPixel(areaSnapshot: IAreaSnapshot, pixels: number, containerSizePixel: number): IAreaAbsorptionCapacity {\r\n    const tempPixelSize = areaSnapshot.sizePixelAtStart + pixels;\r\n            \r\n    // ENLARGE AREA\r\n\r\n    if(pixels > 0) {\r\n        // If maxSize & newSize bigger than it > absorb to max and return remaining pixels \r\n        if(areaSnapshot.area.maxSize !== null && tempPixelSize > areaSnapshot.area.maxSize) {\r\n            return {\r\n                areaSnapshot,\r\n                pixelAbsorb: areaSnapshot.area.maxSize - areaSnapshot.sizePixelAtStart,\r\n                percentAfterAbsorption: -1,\r\n                pixelRemain: tempPixelSize - areaSnapshot.area.maxSize\r\n            };\r\n        }\r\n        return {\r\n            areaSnapshot,\r\n            pixelAbsorb: pixels,\r\n            percentAfterAbsorption: -1,\r\n            pixelRemain: 0\r\n        };\r\n    }\r\n\r\n    // REDUCE AREA\r\n    \r\n    else if(pixels < 0) {\r\n        // If minSize & newSize smaller than it > absorb to min and return remaining pixels \r\n        if(areaSnapshot.area.minSize !== null && tempPixelSize < areaSnapshot.area.minSize) {\r\n            return {\r\n                areaSnapshot,\r\n                pixelAbsorb: areaSnapshot.area.minSize + pixels - tempPixelSize,\r\n                percentAfterAbsorption: -1,\r\n                pixelRemain: tempPixelSize - areaSnapshot.area.minSize\r\n            };\r\n        }\r\n        // If reduced under zero > return remaining pixels\r\n        else if(tempPixelSize < 0) {\r\n            return {\r\n                areaSnapshot,\r\n                pixelAbsorb: -areaSnapshot.sizePixelAtStart,\r\n                percentAfterAbsorption: -1,\r\n                pixelRemain: pixels + areaSnapshot.sizePixelAtStart\r\n            };\r\n        }\r\n        return {\r\n            areaSnapshot,\r\n            pixelAbsorb: pixels,\r\n            percentAfterAbsorption: -1,\r\n            pixelRemain: 0\r\n        };\r\n    }\r\n}\r\n\r\nexport function updateAreaSize(unit: 'percent' | 'pixel', item: IAreaAbsorptionCapacity) {\r\n    \r\n    if(unit === 'percent') {\r\n        item.areaSnapshot.area.size = item.percentAfterAbsorption;\r\n    }\r\n    else if(unit === 'pixel') {\r\n        // Update size except for the wildcard size area\r\n        if(item.areaSnapshot.area.size !== null) {\r\n            item.areaSnapshot.area.size = item.areaSnapshot.sizePixelAtStart + item.pixelAbsorb;\r\n        }\r\n    }\r\n}","import { Component, Input, Output, ChangeDetectionStrategy, ChangeDetectorRef, Renderer2, AfterViewInit, OnDestroy, ElementRef, NgZone, ViewChildren, QueryList, EventEmitter } from '@angular/core';\r\nimport { Observable, Subscriber, Subject } from 'rxjs';\r\nimport { debounceTime } from 'rxjs/operators';\r\n\r\nimport { IArea, IPoint, ISplitSnapshot, IAreaSnapshot, IOutputData, IOutputAreaSizes } from '../interface';\r\nimport { SplitAreaDirective } from '../directive/splitArea.directive';\r\nimport { getInputPositiveNumber, getInputBoolean, isUserSizesValid, getAreaMinSize, getAreaMaxSize, getPointFromEvent, getElementPixelSize, getGutterSideAbsorptionCapacity, updateAreaSize } from '../utils';\r\n\r\n/**\r\n * angular-split\r\n * \r\n * \r\n *  PERCENT MODE ([unit]=\"'percent'\")\r\n *  ___________________________________________________________________________________________\r\n * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |\r\n * |-------------------------------------------------------------------------------------------|\r\n * |       20                 30                 20                 15                 15      | <-- [size]=\"x\"\r\n * |               10px               10px               10px               10px               | <-- [gutterSize]=\"10\"\r\n * |calc(20% - 8px)    calc(30% - 12px)   calc(20% - 8px)    calc(15% - 6px)    calc(15% - 6px)| <-- CSS flex-basis property (with flex-grow&shrink at 0)\r\n * |     152px              228px              152px              114px              114px     | <-- el.getBoundingClientRect().width\r\n * |___________________________________________________________________________________________|\r\n *                                                                                 800px         <-- el.getBoundingClientRect().width\r\n *  flex-basis = calc( { area.size }% - { area.size/100 * nbGutter*gutterSize }px );\r\n * \r\n * \r\n *  PIXEL MODE ([unit]=\"'pixel'\")\r\n *  ___________________________________________________________________________________________\r\n * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       | \r\n * |-------------------------------------------------------------------------------------------|\r\n * |      100                250                 *                 150                100      | <-- [size]=\"y\"\r\n * |               10px               10px               10px               10px               | <-- [gutterSize]=\"10\"\r\n * |   0 0 100px          0 0 250px           1 1 auto          0 0 150px          0 0 100px   | <-- CSS flex property (flex-grow/flex-shrink/flex-basis)\r\n * |     100px              250px              200px              150px              100px     | <-- el.getBoundingClientRect().width\r\n * |___________________________________________________________________________________________|\r\n *                                                                                 800px         <-- el.getBoundingClientRect().width\r\n * \r\n */\r\n\r\n@Component({\r\n    selector: 'as-split',\r\n    exportAs: 'asSplit',\r\n    changeDetection: ChangeDetectionStrategy.OnPush,\r\n    styleUrls: [`./split.component.scss`],\r\n    template: `\r\n        <ng-content></ng-content>\r\n        <ng-template ngFor [ngForOf]=\"displayedAreas\" let-index=\"index\" let-last=\"last\">\r\n            <div *ngIf=\"last === false\" \r\n                 #gutterEls\r\n                 class=\"as-split-gutter\"\r\n                 [style.flex-basis.px]=\"gutterSize\"\r\n                 [style.order]=\"index*2+1\"\r\n                 (mousedown)=\"startDragging($event, index*2+1, index+1)\"\r\n                 (touchstart)=\"startDragging($event, index*2+1, index+1)\"\r\n                 (mouseup)=\"clickGutter($event, index+1)\"\r\n                 (touchend)=\"clickGutter($event, index+1)\">\r\n                <div class=\"as-split-gutter-icon\"></div>\r\n            </div>\r\n        </ng-template>`,\r\n})\r\nexport class SplitComponent implements AfterViewInit, OnDestroy {\r\n\r\n    private _direction: 'horizontal' | 'vertical' = 'horizontal';\r\n\r\n    @Input() set direction(v: 'horizontal' | 'vertical') {\r\n        this._direction = (v === 'vertical') ? 'vertical' : 'horizontal';\r\n        \r\n        this.renderer.addClass(this.elRef.nativeElement, `as-${ this._direction }`);\r\n        this.renderer.removeClass(this.elRef.nativeElement, `as-${ (this._direction === 'vertical') ? 'horizontal' : 'vertical' }`);\r\n        \r\n        this.build(false, false);\r\n    }\r\n    \r\n    get direction(): 'horizontal' | 'vertical' {\r\n        return this._direction;\r\n    }\r\n    \r\n    ////\r\n\r\n    private _unit: 'percent' | 'pixel' = 'percent';\r\n\r\n    @Input() set unit(v: 'percent' | 'pixel') {\r\n        this._unit = (v === 'pixel') ? 'pixel' : 'percent';\r\n        \r\n        this.renderer.addClass(this.elRef.nativeElement, `as-${ this._unit }`);\r\n        this.renderer.removeClass(this.elRef.nativeElement, `as-${ (this._unit === 'pixel') ? 'percent' : 'pixel' }`);\r\n        \r\n        this.build(false, true);\r\n    }\r\n    \r\n    get unit(): 'percent' | 'pixel' {\r\n        return this._unit;\r\n    }\r\n    \r\n    ////\r\n\r\n    private _gutterSize: number = 11;\r\n\r\n    @Input() set gutterSize(v: number | null) {\r\n        this._gutterSize = getInputPositiveNumber(v, 11);\r\n\r\n        this.build(false, false);\r\n    }\r\n    \r\n    get gutterSize(): number {\r\n        return this._gutterSize;\r\n    }\r\n    \r\n    ////\r\n\r\n    private _gutterStep: number = 1;\r\n\r\n    @Input() set gutterStep(v: number) {\r\n        this._gutterStep = getInputPositiveNumber(v, 1);\r\n    }\r\n    \r\n    get gutterStep(): number {\r\n        return this._gutterStep;\r\n    }\r\n    \r\n    ////\r\n\r\n    private _restrictMove: boolean = false;\r\n\r\n    @Input() set restrictMove(v: boolean) {\r\n        this._restrictMove = getInputBoolean(v);\r\n    }\r\n    \r\n    get restrictMove(): boolean {\r\n        return this._restrictMove;\r\n    }\r\n    \r\n    ////\r\n\r\n    private _useTransition: boolean = false;\r\n\r\n    @Input() set useTransition(v: boolean) {\r\n        this._useTransition = getInputBoolean(v);\r\n\r\n        if(this._useTransition) this.renderer.addClass(this.elRef.nativeElement, 'as-transition');\r\n        else                    this.renderer.removeClass(this.elRef.nativeElement, 'as-transition');\r\n    }\r\n    \r\n    get useTransition(): boolean {\r\n        return this._useTransition;\r\n    }\r\n    \r\n    ////\r\n\r\n    private _disabled: boolean = false;\r\n    \r\n    @Input() set disabled(v: boolean) {\r\n        this._disabled = getInputBoolean(v);\r\n\r\n        if(this._disabled)  this.renderer.addClass(this.elRef.nativeElement, 'as-disabled');\r\n        else                this.renderer.removeClass(this.elRef.nativeElement, 'as-disabled');\r\n    }\r\n    \r\n    get disabled(): boolean {\r\n        return this._disabled;\r\n    }\r\n\r\n    ////\r\n\r\n    private _dir: 'ltr' | 'rtl' = 'ltr';\r\n    \r\n    @Input() set dir(v: 'ltr' | 'rtl') {\r\n        this._dir = (v === 'rtl') ? 'rtl' : 'ltr';\r\n        \r\n        this.renderer.setAttribute(this.elRef.nativeElement, 'dir', this._dir);\r\n    }\r\n    \r\n    get dir(): 'ltr' | 'rtl' {\r\n        return this._dir;\r\n    }\r\n    \r\n    ////\r\n\r\n    private _gutterDblClickDuration: number = 0;\r\n\r\n    @Input() set gutterDblClickDuration(v: number) {\r\n        this._gutterDblClickDuration = getInputPositiveNumber(v, 0);\r\n    }\r\n    \r\n    get gutterDblClickDuration(): number {\r\n        return this._gutterDblClickDuration;\r\n    }\r\n\r\n    ////\r\n\r\n    @Output() dragStart = new EventEmitter<IOutputData>(false)\r\n    @Output() dragEnd = new EventEmitter<IOutputData>(false)\r\n    @Output() gutterClick = new EventEmitter<IOutputData>(false)\r\n    @Output() gutterDblClick = new EventEmitter<IOutputData>(false)\r\n\r\n    private transitionEndSubscriber: Subscriber<IOutputAreaSizes>\r\n    @Output() get transitionEnd(): Observable<IOutputAreaSizes> {\r\n        return new Observable(subscriber => this.transitionEndSubscriber = subscriber).pipe(\r\n            debounceTime<IOutputAreaSizes>(20)\r\n        );\r\n    }\r\n    \r\n    private dragProgressSubject: Subject<IOutputData> = new Subject();\r\n    dragProgress$: Observable<IOutputData> = this.dragProgressSubject.asObservable();\r\n\r\n    ////\r\n\r\n    private isDragging: boolean = false;\r\n    private dragListeners: Array<Function> = [];\r\n    private snapshot: ISplitSnapshot | null = null;\r\n    private startPoint: IPoint | null = null;\r\n    private endPoint: IPoint | null = null;\r\n\r\n    public readonly displayedAreas: Array<IArea> = [];\r\n    private readonly hidedAreas: Array<IArea> = [];\r\n\r\n    @ViewChildren('gutterEls') private gutterEls: QueryList<ElementRef>;\r\n\r\n    constructor(private ngZone: NgZone,\r\n                private elRef: ElementRef,\r\n                private cdRef: ChangeDetectorRef,\r\n                private renderer: Renderer2) {\r\n        // To force adding default class, could be override by user @Input() or not\r\n        this.direction = this._direction;\r\n    }\r\n\r\n    public ngAfterViewInit() {\r\n        this.ngZone.runOutsideAngular(() => {\r\n            // To avoid transition at first rendering\r\n            setTimeout(() => this.renderer.addClass(this.elRef.nativeElement, 'as-init'));\r\n        });\r\n    }\r\n    \r\n    private getNbGutters(): number {\r\n        return (this.displayedAreas.length === 0) ? 0 : this.displayedAreas.length - 1;\r\n    }\r\n\r\n    public addArea(component: SplitAreaDirective): void {\r\n        const newArea: IArea = {\r\n            component, \r\n            order: 0, \r\n            size: 0,\r\n            minSize: null,\r\n            maxSize: null,\r\n        };\r\n\r\n        if(component.visible === true) {\r\n            this.displayedAreas.push(newArea);\r\n\r\n            this.build(true, true);\r\n        }\r\n        else {\r\n            this.hidedAreas.push(newArea);\r\n        }\r\n    }\r\n\r\n    public removeArea(component: SplitAreaDirective): void {\r\n        if(this.displayedAreas.some(a => a.component === component)) {\r\n            const area = this.displayedAreas.find(a => a.component === component);\r\n            this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\r\n\r\n            this.build(true, true);\r\n        }\r\n        else if(this.hidedAreas.some(a => a.component === component)) {\r\n            const area = this.hidedAreas.find(a => a.component === component);\r\n            this.hidedAreas.splice(this.hidedAreas.indexOf(area), 1);\r\n        }\r\n    }\r\n\r\n    public updateArea(component: SplitAreaDirective, resetOrders: boolean, resetSizes: boolean): void {\r\n        if(component.visible === true) {\r\n            this.build(resetOrders, resetSizes);\r\n        }\r\n    }\r\n\r\n    public showArea(component: SplitAreaDirective): void {\r\n        const area = this.hidedAreas.find(a => a.component === component);\r\n        if(area === undefined) {\r\n            return;\r\n        }\r\n\r\n        const areas = this.hidedAreas.splice(this.hidedAreas.indexOf(area), 1);\r\n        this.displayedAreas.push(...areas);\r\n\r\n        this.build(true, true);\r\n    }\r\n\r\n    public hideArea(comp: SplitAreaDirective): void {\r\n        const area = this.displayedAreas.find(a => a.component === comp);\r\n        if(area === undefined) {\r\n            return;\r\n        }\r\n\r\n        const areas = this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\r\n        areas.forEach(area => {\r\n            area.order = 0;\r\n            area.size = 0;\r\n        })\r\n        this.hidedAreas.push(...areas);\r\n\r\n        this.build(true, true);\r\n    }\r\n\r\n    public getVisibleAreaSizes(): IOutputAreaSizes {\r\n        return this.displayedAreas.map(a => a.size === null ? '*' : a.size);\r\n    }\r\n\r\n    public setVisibleAreaSizes(sizes: IOutputAreaSizes): boolean {\r\n        if(sizes.length !== this.displayedAreas.length) {\r\n            return false;\r\n        }\r\n\r\n        const formatedSizes = sizes.map(s => getInputPositiveNumber(s, null));\r\n        const isValid = isUserSizesValid(this.unit, formatedSizes);\r\n\r\n        if(isValid === false) {\r\n            return false;\r\n        }\r\n\r\n        // @ts-ignore\r\n        this.displayedAreas.forEach((area, i) => area.component._size = formatedSizes[i]);\r\n\r\n        this.build(false, true);\r\n        return true;\r\n    }\r\n\r\n    private build(resetOrders: boolean, resetSizes: boolean): void {\r\n        this.stopDragging();\r\n\r\n        //  AREAS ORDER\r\n        \r\n        if(resetOrders === true) {\r\n\r\n            // If user provided 'order' for each area, use it to sort them.\r\n            if(this.displayedAreas.every(a => a.component.order !== null)) {\r\n                this.displayedAreas.sort((a, b) => (<number> a.component.order) - (<number> b.component.order));\r\n            }\r\n    \r\n            // Then set real order with multiples of 2, numbers between will be used by gutters.\r\n            this.displayedAreas.forEach((area, i) => {\r\n                area.order = i * 2;\r\n                area.component.setStyleOrder(area.order);\r\n            });\r\n        }\r\n\r\n        //  AREAS SIZE\r\n        \r\n        if(resetSizes === true) {\r\n            const useUserSizes = isUserSizesValid(this.unit, this.displayedAreas.map(a => a.component.size));\r\n\r\n            switch(this.unit) {\r\n                case 'percent': {\r\n                    const defaultSize = 100 / this.displayedAreas.length;\r\n    \r\n                    this.displayedAreas.forEach(area => {\r\n                        area.size = useUserSizes ? <number> area.component.size : defaultSize;\r\n                        area.minSize = getAreaMinSize(area);\r\n                        area.maxSize = getAreaMaxSize(area);\r\n                    });\r\n                    break;\r\n                }\r\n                case 'pixel': {\r\n                    if(useUserSizes) {\r\n                        this.displayedAreas.forEach(area => {\r\n                            area.size = area.component.size;\r\n                            area.minSize = getAreaMinSize(area);\r\n                            area.maxSize = getAreaMaxSize(area);\r\n                        });\r\n                    }\r\n                    else {\r\n                        const wildcardSizeAreas = this.displayedAreas.filter(a => a.component.size === null);\r\n    \r\n                        // No wildcard area > Need to select one arbitrarily > first\r\n                        if(wildcardSizeAreas.length === 0 && this.displayedAreas.length > 0) {\r\n\r\n                            this.displayedAreas.forEach((area, i) => {\r\n                                area.size = (i === 0) ? null : area.component.size;\r\n                                area.minSize = (i === 0) ? null : getAreaMinSize(area);\r\n                                area.maxSize = (i === 0) ? null : getAreaMaxSize(area);\r\n                            });\r\n                        }\r\n                        // More than one wildcard area > Need to keep only one arbitrarly > first\r\n                        else if(wildcardSizeAreas.length > 1) {\r\n\r\n                            let alreadyGotOne = false;\r\n                            this.displayedAreas.forEach(area => {\r\n                                if(area.component.size === null) {\r\n                                    if(alreadyGotOne === false) {\r\n                                        area.size = null;\r\n                                        area.minSize = null;\r\n                                        area.maxSize = null;\r\n                                        alreadyGotOne = true;\r\n                                    }\r\n                                    else {\r\n                                        area.size = 100;\r\n                                        area.minSize = null;\r\n                                        area.maxSize = null;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    area.size = area.component.size;\r\n                                    area.minSize = getAreaMinSize(area);\r\n                                    area.maxSize = getAreaMaxSize(area);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.refreshStyleSizes();\r\n        this.cdRef.markForCheck();\r\n    }\r\n\r\n    private refreshStyleSizes(): void {\r\n        ///////////////////////////////////////////\r\n        // PERCENT MODE\r\n        if(this.unit === 'percent') {\r\n            // Only one area > flex-basis 100%\r\n            if(this.displayedAreas.length === 1) {\r\n                this.displayedAreas[0].component.setStyleFlex(0, 0, `100%`, false, false);\r\n            }\r\n            // Multiple areas > use each percent basis\r\n            else {\r\n                const sumGutterSize = this.getNbGutters() * this.gutterSize;\r\n                \r\n                this.displayedAreas.forEach(area => {\r\n                    area.component.setStyleFlex(\r\n                        0, 0, `calc( ${ area.size }% - ${ <number> area.size / 100 * sumGutterSize }px )`,\r\n                        (area.minSize !== null && area.minSize === area.size) ? true : false,\r\n                        (area.maxSize !== null && area.maxSize === area.size) ? true : false,\r\n                    );\r\n                });\r\n            } \r\n        }\r\n        ///////////////////////////////////////////\r\n        // PIXEL MODE\r\n        else if(this.unit === 'pixel') {\r\n            this.displayedAreas.forEach(area => {\r\n                // Area with wildcard size\r\n                if(area.size === null) {\r\n                    if(this.displayedAreas.length === 1) {\r\n                        area.component.setStyleFlex(1, 1, `100%`, false, false);\r\n                    }\r\n                    else {\r\n                        area.component.setStyleFlex(1, 1, `auto`, false, false);\r\n                    }\r\n                }\r\n                // Area with pixel size\r\n                else {\r\n                    // Only one area > flex-basis 100%\r\n                    if(this.displayedAreas.length === 1) {\r\n                        area.component.setStyleFlex(0, 0, `100%`, false, false);\r\n                    }\r\n                    // Multiple areas > use each pixel basis\r\n                    else {\r\n                        area.component.setStyleFlex(\r\n                            0, 0, `${ area.size }px`,\r\n                            (area.minSize !== null && area.minSize === area.size) ? true : false,\r\n                            (area.maxSize !== null && area.maxSize === area.size) ? true : false,\r\n                        );\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    _clickTimeout: number | null = null\r\n\r\n    public clickGutter(event: MouseEvent | TouchEvent, gutterNum: number): void {\r\n        const tempPoint = getPointFromEvent(event);\r\n\r\n        // Be sure mouseup/touchend happened at same point as mousedown/touchstart to trigger click/dblclick\r\n        if(this.startPoint && this.startPoint.x === tempPoint.x && this.startPoint.y === tempPoint.y) {\r\n\r\n            // If timeout in progress and new click > clearTimeout & dblClickEvent\r\n            if(this._clickTimeout !== null) {\r\n                window.clearTimeout(this._clickTimeout);\r\n                this._clickTimeout = null;\r\n                this.notify('dblclick', gutterNum);\r\n                this.stopDragging();\r\n            }\r\n            // Else start timeout to call clickEvent at end\r\n            else {\r\n                this._clickTimeout = window.setTimeout(() => {\r\n                    this._clickTimeout = null;\r\n                    this.notify('click', gutterNum);\r\n                    this.stopDragging();\r\n                }, this.gutterDblClickDuration);\r\n            }\r\n        }\r\n    }\r\n\r\n    public startDragging(event: MouseEvent | TouchEvent, gutterOrder: number, gutterNum: number): void {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        this.startPoint = getPointFromEvent(event);\r\n        if(this.startPoint === null || this.disabled === true) {\r\n            return;\r\n        }\r\n\r\n        this.snapshot = {\r\n            gutterNum,\r\n            lastSteppedOffset: 0,\r\n            allAreasSizePixel: getElementPixelSize(this.elRef, this.direction) - this.getNbGutters() * this.gutterSize,\r\n            allInvolvedAreasSizePercent: 100,\r\n            areasBeforeGutter: [],\r\n            areasAfterGutter: [],\r\n        };\r\n\r\n        this.displayedAreas.forEach(area => {\r\n            const areaSnapshot: IAreaSnapshot = {\r\n                area,\r\n                sizePixelAtStart: getElementPixelSize(area.component.elRef, this.direction),\r\n                sizePercentAtStart: (this.unit === 'percent') ? area.size : -1 // If pixel mode, anyway, will not be used.\r\n            };\r\n\r\n            if(area.order < gutterOrder) {\r\n                if(this.restrictMove === true) {\r\n                    this.snapshot.areasBeforeGutter = [areaSnapshot];\r\n                }\r\n                else {\r\n                    this.snapshot.areasBeforeGutter.unshift(areaSnapshot);\r\n                }\r\n            }\r\n            else if(area.order > gutterOrder) {\r\n                if(this.restrictMove === true) {\r\n                    if(this.snapshot.areasAfterGutter.length === 0) this.snapshot.areasAfterGutter = [areaSnapshot];\r\n                }\r\n                else {\r\n                    this.snapshot.areasAfterGutter.push(areaSnapshot);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.snapshot.allInvolvedAreasSizePercent = [...this.snapshot.areasBeforeGutter, ...this.snapshot.areasAfterGutter].reduce((t, a) => t+a.sizePercentAtStart, 0);\r\n        \r\n        if(this.snapshot.areasBeforeGutter.length === 0 || this.snapshot.areasAfterGutter.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.dragListeners.push( this.renderer.listen('document', 'mouseup', this.stopDragging.bind(this)) );\r\n        this.dragListeners.push( this.renderer.listen('document', 'touchend', this.stopDragging.bind(this)) );\r\n        this.dragListeners.push( this.renderer.listen('document', 'touchcancel', this.stopDragging.bind(this)) );\r\n        \r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.dragListeners.push( this.renderer.listen('document', 'mousemove', this.dragEvent.bind(this)) );\r\n            this.dragListeners.push( this.renderer.listen('document', 'touchmove', this.dragEvent.bind(this)) );\r\n        });\r\n\r\n        this.displayedAreas.forEach(area => area.component.lockEvents());\r\n\r\n        this.isDragging = true;\r\n        this.renderer.addClass(this.elRef.nativeElement, 'as-dragging');\r\n        this.renderer.addClass(this.gutterEls.toArray()[this.snapshot.gutterNum - 1].nativeElement, 'as-dragged');\r\n        \r\n        this.notify('start', this.snapshot.gutterNum);\r\n    }\r\n\r\n    private dragEvent(event: MouseEvent | TouchEvent): void {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        if(this._clickTimeout !== null) {\r\n            window.clearTimeout(this._clickTimeout);\r\n            this._clickTimeout = null;\r\n        }\r\n\r\n        if(this.isDragging === false) {\r\n            return;\r\n        }\r\n\r\n        this.endPoint = getPointFromEvent(event);\r\n        if(this.endPoint === null) {\r\n            return;\r\n        }\r\n\r\n        // Calculate steppedOffset\r\n\r\n        let offset = (this.direction === 'horizontal') ? (this.startPoint.x - this.endPoint.x) : (this.startPoint.y - this.endPoint.y);\r\n        if(this.dir === 'rtl') {\r\n            offset = -offset;\r\n        }\r\n        const steppedOffset = Math.round(offset / this.gutterStep) * this.gutterStep;\r\n        \r\n        if(steppedOffset === this.snapshot.lastSteppedOffset) {\r\n            return;\r\n        }\r\n        \r\n        this.snapshot.lastSteppedOffset = steppedOffset;\r\n        \r\n        // Need to know if each gutter side areas could reacts to steppedOffset\r\n        \r\n        let areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -steppedOffset, this.snapshot.allAreasSizePixel);\r\n        let areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset, this.snapshot.allAreasSizePixel);\r\n\r\n        // Each gutter side areas can't absorb all offset \r\n        if(areasBefore.remain !== 0 && areasAfter.remain !== 0) {\r\n            if(Math.abs(areasBefore.remain) === Math.abs(areasAfter.remain)) {\r\n            }\r\n            else if(Math.abs(areasBefore.remain) > Math.abs(areasAfter.remain)) {\r\n                areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset + areasBefore.remain, this.snapshot.allAreasSizePixel);\r\n            }\r\n            else {\r\n                areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -(steppedOffset - areasAfter.remain), this.snapshot.allAreasSizePixel);\r\n            }\r\n        }\r\n        // Areas before gutter can't absorbs all offset > need to recalculate sizes for areas after gutter.\r\n        else if(areasBefore.remain !== 0) {\r\n            areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset + areasBefore.remain, this.snapshot.allAreasSizePixel);\r\n        }\r\n        // Areas after gutter can't absorbs all offset > need to recalculate sizes for areas before gutter.\r\n        else if(areasAfter.remain !== 0) {\r\n            areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -(steppedOffset - areasAfter.remain), this.snapshot.allAreasSizePixel);\r\n        }\r\n\r\n        if(this.unit === 'percent') {\r\n            // Hack because of browser messing up with sizes using calc(X% - Ypx) -> el.getBoundingClientRect()\r\n            // If not there, playing with gutters makes total going down to 99.99875% then 99.99286%, 99.98986%,..\r\n            const all = [...areasBefore.list, ...areasAfter.list];\r\n            const areaToReset = all.find(a => a.percentAfterAbsorption !== 0 && a.percentAfterAbsorption !== a.areaSnapshot.area.minSize && a.percentAfterAbsorption !== a.areaSnapshot.area.maxSize)\r\n\r\n            if(areaToReset) {\r\n                areaToReset.percentAfterAbsorption = this.snapshot.allInvolvedAreasSizePercent - all.filter(a => a !== areaToReset).reduce((total, a) => total+a.percentAfterAbsorption, 0);\r\n            }\r\n        }\r\n\r\n        // Now we know areas could absorb steppedOffset, time to really update sizes\r\n        \r\n        areasBefore.list.forEach(item => updateAreaSize(this.unit, item));\r\n        areasAfter.list.forEach(item => updateAreaSize(this.unit, item));\r\n        \r\n        this.refreshStyleSizes();\r\n        this.notify('progress', this.snapshot.gutterNum);\r\n    }\r\n\r\n    private stopDragging(event?: Event): void {\r\n        if(event) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n        }\r\n        \r\n        if(this.isDragging === false) {\r\n            return;\r\n        }\r\n        \r\n        this.displayedAreas.forEach(area => area.component.unlockEvents());\r\n        \r\n        while(this.dragListeners.length > 0) {\r\n            const fct = this.dragListeners.pop();\r\n            if(fct) fct();\r\n        }\r\n        \r\n        // Warning: Have to be before \"notify('end')\" \r\n        // because \"notify('end')\"\" can be linked to \"[size]='x'\" > \"build()\" > \"stopDragging()\"\r\n        this.isDragging = false;\r\n\r\n        // If moved from starting point, notify end\r\n        if(this.endPoint && (this.startPoint.x !== this.endPoint.x || this.startPoint.y !== this.endPoint.y)) {\r\n            this.notify('end', this.snapshot.gutterNum);\r\n        }\r\n        \r\n        this.renderer.removeClass(this.elRef.nativeElement, 'as-dragging');\r\n        this.renderer.removeClass(this.gutterEls.toArray()[this.snapshot.gutterNum - 1].nativeElement, 'as-dragged');\r\n        this.snapshot = null;\r\n\r\n        // Needed to let (click)=\"clickGutter(...)\" event run and verify if mouse moved or not\r\n        this.ngZone.runOutsideAngular(() => {\r\n            setTimeout(() => {\r\n                this.startPoint = null;\r\n                this.endPoint = null;\r\n            })\r\n        });\r\n    }\r\n\r\n    public notify(type: 'start' | 'progress' | 'end' | 'click' | 'dblclick' | 'transitionEnd', gutterNum: number): void {\r\n        const sizes = this.getVisibleAreaSizes();\r\n\r\n        if(type === 'start') {\r\n            this.dragStart.emit({gutterNum, sizes});\r\n        }\r\n        else if(type === 'end') {\r\n            this.dragEnd.emit({gutterNum, sizes});\r\n        }\r\n        else if(type === 'click') {\r\n            this.gutterClick.emit({gutterNum, sizes});\r\n        }\r\n        else if(type === 'dblclick') {\r\n            this.gutterDblClick.emit({gutterNum, sizes});\r\n        }\r\n        else if(type === 'transitionEnd') {\r\n            if(this.transitionEndSubscriber) {\r\n                this.ngZone.run(() => this.transitionEndSubscriber.next(sizes));\r\n            }\r\n        }\r\n        else if(type === 'progress') {\r\n            // Stay outside zone to allow users do what they want about change detection mechanism.\r\n            this.dragProgressSubject.next({gutterNum, sizes});\r\n        }\r\n    }\r\n\r\n    public ngOnDestroy(): void {\r\n        this.stopDragging();\r\n    }\r\n}\r\n","import { Directive, Input, ElementRef, Renderer2, OnInit, OnDestroy, NgZone } from '@angular/core';\r\n\r\nimport { SplitComponent } from '../component/split.component';\r\nimport { getInputPositiveNumber, getInputBoolean } from '../utils';\r\n\r\n@Directive({\r\n    selector: 'as-split-area, [as-split-area]',\r\n    exportAs: 'asSplitArea'\r\n})\r\nexport class SplitAreaDirective implements OnInit, OnDestroy {\r\n\r\n    private _order: number | null = null;\r\n\r\n    @Input() set order(v: number | null) {\r\n        this._order = getInputPositiveNumber(v, null);\r\n\r\n        this.split.updateArea(this, true, false);\r\n    }\r\n    \r\n    get order(): number | null {\r\n        return this._order;\r\n    }\r\n\r\n    ////\r\n\r\n    private _size: number | null = null;\r\n\r\n    @Input() set size(v: number | null) {\r\n        this._size = getInputPositiveNumber(v, null);\r\n\r\n        this.split.updateArea(this, false, true);\r\n    }\r\n    \r\n    get size(): number | null {\r\n        return this._size;\r\n    }\r\n\r\n    ////\r\n\r\n    private _minSize: number | null = null;\r\n\r\n    @Input() set minSize(v: number | null) {\r\n        this._minSize = getInputPositiveNumber(v, null);\r\n\r\n        this.split.updateArea(this, false, true);\r\n    }\r\n    \r\n    get minSize(): number | null {\r\n        return this._minSize;\r\n    }\r\n\r\n    ////\r\n\r\n    private _maxSize: number | null = null;\r\n\r\n    @Input() set maxSize(v: number | null) {\r\n        this._maxSize = getInputPositiveNumber(v, null);\r\n\r\n        this.split.updateArea(this, false, true);\r\n    }\r\n    \r\n    get maxSize(): number | null {\r\n        return this._maxSize;\r\n    }\r\n\r\n    ////\r\n\r\n    private _lockSize: boolean = false;\r\n\r\n    @Input() set lockSize(v: boolean) {\r\n        this._lockSize = getInputBoolean(v);\r\n\r\n        this.split.updateArea(this, false, true);\r\n    }\r\n    \r\n    get lockSize(): boolean {\r\n        return this._lockSize;\r\n    }\r\n\r\n    ////\r\n\r\n    private _visible: boolean = true;\r\n\r\n    @Input() set visible(v: boolean) {\r\n        this._visible = getInputBoolean(v);\r\n\r\n        if(this._visible) { \r\n            this.split.showArea(this);\r\n            this.renderer.removeClass(this.elRef.nativeElement, 'as-hidden');\r\n        }\r\n        else {\r\n            this.split.hideArea(this);\r\n            this.renderer.addClass(this.elRef.nativeElement, 'as-hidden');\r\n        }\r\n    }\r\n\r\n    get visible(): boolean {\r\n        return this._visible;\r\n    }\r\n\r\n    ////\r\n\r\n    private transitionListener: Function;\r\n    private readonly lockListeners: Array<Function> = [];\r\n\r\n    constructor(private ngZone: NgZone,\r\n                public elRef: ElementRef,\r\n                private renderer: Renderer2,\r\n                private split: SplitComponent) {\r\n        this.renderer.addClass(this.elRef.nativeElement, 'as-split-area');\r\n    }\r\n\r\n    public ngOnInit(): void {\r\n        this.split.addArea(this);\r\n\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.transitionListener = this.renderer.listen(this.elRef.nativeElement, 'transitionend', (event: TransitionEvent) => {\r\n                // Limit only flex-basis transition to trigger the event\r\n                if(event.propertyName === 'flex-basis') {\r\n                    this.split.notify('transitionEnd', -1);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    public setStyleOrder(value: number): void {\r\n        this.renderer.setStyle(this.elRef.nativeElement, 'order', value);\r\n    }\r\n    \r\n    public setStyleFlex(grow: number, shrink: number, basis: string, isMin: boolean, isMax: boolean): void {\r\n        // Need 3 separated properties to work on IE11 (https://github.com/angular/flex-layout/issues/323)\r\n        this.renderer.setStyle(this.elRef.nativeElement, 'flex-grow', grow);\r\n        this.renderer.setStyle(this.elRef.nativeElement, 'flex-shrink', shrink);\r\n        this.renderer.setStyle(this.elRef.nativeElement, 'flex-basis', basis);\r\n        \r\n        if(isMin === true)  this.renderer.addClass(this.elRef.nativeElement, 'as-min');\r\n        else                this.renderer.removeClass(this.elRef.nativeElement, 'as-min');\r\n        \r\n        if(isMax === true)  this.renderer.addClass(this.elRef.nativeElement, 'as-max');\r\n        else                this.renderer.removeClass(this.elRef.nativeElement, 'as-max');\r\n    }\r\n    \r\n    public lockEvents(): void {\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.lockListeners.push( this.renderer.listen(this.elRef.nativeElement, 'selectstart', (e: Event) => false) );\r\n            this.lockListeners.push( this.renderer.listen(this.elRef.nativeElement, 'dragstart', (e: Event) => false) );\r\n        });\r\n    }\r\n\r\n    public unlockEvents(): void {\r\n        while(this.lockListeners.length > 0) {\r\n            const fct = this.lockListeners.pop();\r\n            if(fct) fct();\r\n        }\r\n    }\r\n\r\n    public ngOnDestroy(): void {\r\n        this.unlockEvents();\r\n\r\n        if(this.transitionListener) {\r\n            this.transitionListener();\r\n        }\r\n\r\n        this.split.removeArea(this);\r\n    }\r\n}\r\n","import { NgModule, ModuleWithProviders } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\n\r\nimport { SplitComponent } from './component/split.component';\r\nimport { SplitAreaDirective } from './directive/splitArea.directive';\r\n\r\n@NgModule({\r\n    imports: [\r\n        CommonModule\r\n    ],\r\n    declarations: [\r\n        SplitComponent,\r\n        SplitAreaDirective,\r\n    ],\r\n    exports: [\r\n        SplitComponent,\r\n        SplitAreaDirective,\r\n    ]\r\n})\r\nexport class AngularSplitModule {\r\n\r\n    public static forRoot(): ModuleWithProviders {\r\n        return {\r\n            ngModule: AngularSplitModule,\r\n            providers: []\r\n        };\r\n    }\r\n\r\n    public static forChild(): ModuleWithProviders {\r\n        return {\r\n            ngModule: AngularSplitModule,\r\n            providers: []\r\n        };\r\n    }\r\n\r\n}\r\n"]}